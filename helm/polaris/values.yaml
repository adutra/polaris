#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#

# -- The number of replicas to deploy (horizontal scaling).
# Beware that replicas are stateless; don't set this number > 1 when using in-memory meta store manager.
replicaCount: 1

image:
  # -- The image repository to pull from.
  repository: apache/polaris
  # -- The image pull policy.
  pullPolicy: IfNotPresent
  # -- The image tag.
  tag: "latest"
  # -- The path to the directory where the application.properties file, and other configuration
  # files, if any, should be mounted.
  configDir: /deployments/config

# -- References to secrets in the same namespace to use for pulling any of the images used by this
# chart. Each entry is a LocalObjectReference to an existing secret in the namespace. The secret
# must contain a .dockerconfigjson key with a base64-encoded Docker configuration file. See
# https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/ for more
# information.
imagePullSecrets: []
#  - registry-creds


serviceAccount:
  # -- Specifies whether a service account should be created.
  create: true
  # -- Annotations to add to the service account.
  annotations: {}
  # -- The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template.
  name: ""


# -- Annotations to apply to polaris pods.
podAnnotations: {}

# -- Additional Labels to apply to polaris pods.
podLabels: {}

# -- Additional Labels to apply to polaris configmap.
configMapLabels: {}

# -- The number of old ReplicaSets to retain to allow rollback (if not set, the default Kubernetes value is set to 10).
revisionHistoryLimit: ~

# -- Security context for the polaris pod. See https://kubernetes.io/docs/tasks/configure-pod-container/security-context/.
podSecurityContext:
  {}
  # fsGroup: 2000

# -- Security context for the polaris container. See https://kubernetes.io/docs/tasks/configure-pod-container/security-context/.
containerSecurityContext:
  {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

# -- Polaris main service settings.
service:
  # -- The type of service to create.
  type: ClusterIP
  # -- The ports the service will listen on.
  # At least one port is required; the first port implicitly becomes the HTTP port that the
  # application will use for serving API requests. By default, it's 8181.
  # Note: port names must be unique and no more than 15 characters long.
  ports:
    - name: polaris-http
      port: 8181
      # targetPort: 8181
      # nodePort: 30000
      # protocol: TCP
    # - name: polaris-https
    #  port: 18181
  # -- The session affinity for the service. Valid values are: None, ClientIP.
  # ClientIP enables sticky sessions based on the client's IP address.
  # This is generally beneficial to Polaris deployments, but some testing may be
  # required in order to make sure that the load is distributed evenly among the pods.
  # Also, this setting affects only internal clients, not external ones.
  # If Ingress is enabled, it is recommended to set sessionAffinity to None.
  sessionAffinity: None
  # -- You can specify your own cluster IP address
  # If you define a Service that has the .spec.clusterIP set to "None" then Kubernetes does not assign an IP address.
  # Instead, DNS records for the service will return the IP addresses of each pod targeted by the server. This is
  # called a headless service.
  # See https://kubernetes.io/docs/concepts/services-networking/service/#headless-services
  clusterIP: ""
  # -- The traffic policy fields control how traffic from internal and external sources are routed respectively.
  # Valid values are Cluster and Local.
  # Set the field to Cluster to route traffic to all ready endpoints.
  # Set the field to Local to only route to ready node-local endpoints.
  # If the traffic policy is Local and there are no node-local endpoints, traffic is dropped by kube-proxy
  internalTrafficPolicy: Cluster
  externalTrafficPolicy: Cluster
  # -- The traffic distribution field provides another way to influence traffic routing within a Kubernetes Service.
  # While traffic policies focus on strict semantic guarantees, traffic distribution allows you to express preferences
  # such as routing to topologically closer endpoints.
  # Valid values are: PreferClose
  trafficDistribution: PreferClose
  # -- Annotations to add to the service.
  annotations: {}

# -- Management service settings. These settings are used to configure liveness and readiness probes,
# and to configure the dedicated headless service that will expose health checks and metrics, e.g.
# for metrics scraping and service monitoring.
managementService:
  # -- The type of service to create.
  type: ClusterIP
  # -- The ports the management service will listen on.
  # At least one port is required; the first port implicitly becomes the HTTP port that the
  # application will use for serving management requests. By default, it's 8182.
  # Note: port names must be unique and no more than 15 characters long.
  ports:
    # -- The name of the management port. Required.
    - name: polaris-mgmt
      # -- The port the management service listens on. By default, the management interface is exposed
      # on HTTP port 8182.
      port: 8182
      # targetPort: polaris-service
      # nodePort: 30000
  clusterIP: None
  sessionAffinity: ~
  internalTrafficPolicy: ~
  externalTrafficPolicy: ~
  trafficDistribution: ~
  # -- Annotations to add to the service.
  annotations: {}

# -- Additional service definitions. All service definitions always select all Polaris pods. Use
# this if you need to expose specific ports with different configurations, e.g. expose polaris-http
# with an alternate LoadBalancer service instead of ClusterIP.
extraServices: []
  #  - # -- The suffix to append to the service name. Required. It must be unique. If it does not
  #    # start with a hyphen, a hyphen will be inserted between the base service name and the suffix.
  #    nameSuffix: "ext"
  #    # -- The type of service to create.
  #    type: LoadBalancer
  #    # -- The ports the service will listen on.
  #    ports:
  #    - name: polaris-http
  #      number: 8181
  #    sessionAffinity: None
  #    clusterIP: ""
  #    internalTrafficPolicy: Cluster
  #    externalTrafficPolicy: Cluster
  #    trafficDistribution: PreferClose
  #    annotations: {}

# Polaris Ingress settings.
# These settings generate an Ingress resource that routes external traffic to the Polaris service
# using the "polaris-service" port described above.
# Consider enabling sticky sessions based on the remote client's IP address;
# this is generally beneficial to Polaris deployments, but some testing may be
# required in order to make sure that the load is distributed evenly among the pods.
# Check your ingress controller's documentation.
ingress:
  # -- Specifies the ingressClassName; leave empty if you don't want to customize it
  className: ""
  # -- Specifies whether an ingress should be created.
  enabled: false
  # -- Annotations to add to the ingress.
  annotations: {
    # nginx.ingress.kubernetes.io/upstream-hash-by: "$binary_remote_addr"
  }
  # -- A list of host paths used to configure the ingress.
  hosts:
    - host: chart-example.local
      paths: []
  # -- A list of TLS certificates; each entry has a list of hosts in the certificate,
  # along with the secret name used to terminate TLS traffic on port 443.
  tls: []
#    - hosts:
#        - chart-example1.local
#        - chart-example2.local
#      secretName: secret1

# -- Configures the resources requests and limits for polaris pods.
# We usually recommend not to specify default resources and to leave this as a conscious
# choice for the user. This also increases chances charts run on environments with little
# resources, such as Minikube. If you do want to specify resources, uncomment the following
# lines, adjust them as necessary, and remove the curly braces after 'resources:'.
resources:
  {}
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

autoscaling:
  # -- Specifies whether automatic horizontal scaling should be enabled.
  # Do not enable this when using in-memory version store type.
  enabled: false
  # -- The minimum number of replicas to maintain.
  minReplicas: 1
  # -- The maximum number of replicas to maintain.
  maxReplicas: 3
  # -- Optional; set to zero or empty to disable.
  targetCPUUtilizationPercentage: 80
  # -- Optional; set to zero or empty to disable.
  targetMemoryUtilizationPercentage:

# -- Node labels which must match for the polaris pod to be scheduled on that node. See https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector.
nodeSelector:
  {}
  # kubernetes.io/os: linux

# -- A list of tolerations to apply to polaris pods. See https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/.
tolerations: []
#  - key: "node-role.kubernetes.io/control-plane"
#    operator: "Exists"
#    effect: "NoSchedule"

# -- Affinity and anti-affinity for polaris pods. See https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity.
affinity: {}
#  podAffinity:
#    preferredDuringSchedulingIgnoredDuringExecution:
#      - weight: 100
#        podAffinityTerm:
#          topologyKey: kubernetes.io/hostname
#          labelSelector:
#            matchExpressions:
#              - key: app.kubernetes.io/name
#                operator: In
#                values:
#                  - polaris

# -- Configures the liveness probe for polaris pods.
livenessProbe:
  # -- Number of seconds after the container has started before liveness probes are initiated. Minimum value is 0.
  initialDelaySeconds: 5
  # -- How often (in seconds) to perform the probe. Minimum value is 1.
  periodSeconds: 10
  # -- Minimum consecutive successes for the probe to be considered successful after having failed. Minimum value is 1.
  successThreshold: 1
  # -- Minimum consecutive failures for the probe to be considered failed after having succeeded. Minimum value is 1.
  failureThreshold: 3
  # -- Number of seconds after which the probe times out. Minimum value is 1.
  timeoutSeconds: 10
  # -- Optional duration in seconds the pod needs to terminate gracefully upon probe failure. Minimum value is 1.
  terminationGracePeriodSeconds: 30

# -- Configures the readiness probe for polaris pods.
readinessProbe:
  # -- Number of seconds after the container has started before readiness probes are initiated. Minimum value is 0.
  initialDelaySeconds: 5
  # -- How often (in seconds) to perform the probe. Minimum value is 1.
  periodSeconds: 10
  # -- Minimum consecutive successes for the probe to be considered successful after having failed. Minimum value is 1.
  successThreshold: 1
  # -- Minimum consecutive failures for the probe to be considered failed after having succeeded. Minimum value is 1.
  failureThreshold: 3
  # -- Number of seconds after which the probe times out. Minimum value is 1.
  timeoutSeconds: 10

# -- Advanced configuration.
# You can pass here any valid Polaris or Quarkus configuration property.
# Any property that is defined here takes precedence over all the other configuration values generated by this chart.
# Properties can be passed "flattened" or as nested YAML objects (see examples below).
# Note: values should be strings; avoid using numbers, booleans, or other types.
advancedConfig:
# # Disable access log:
# quarkus.http.access-log.enabled: "true"
# # Reverse Proxy Settings
# # ----------------------
# #
# # These config options are mentioned only for documentation purposes. Consult the
# # Quarkus documentation for "Running behind a reverse proxy" and configure those
# # depending on your actual needs.
#
# # See https://quarkus.io/guides/http-reference#reverse-proxy
#
# # Do NOT enable these option unless your reverse proxy (for example istio or nginx)
# # is properly setup to set these headers but also filter those from incoming requests.
#
#  quarkus:
#   http:
#     proxy:
#       proxy-address-forwarding: "true"
#       allow-x-forwarded: "true"
#       enable-forwarded-host: "true"
#       enable-forwarded-prefix: "true"
#       trusted-proxies: "127.0.0.1"
  {}

# -- Advanced configuration via Environment Variables.
# Extra environment variables to add to the Polaris server container.
# You can pass here any valid EnvVar object:
# https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.27/#envvar-v1-core
# This can be useful to get configuration values from Kubernetes secrets or config maps.
extraEnv:
  []
#  - name: AWS_STORAGE_BUCKET
#    value: s3://xxxxx/
#  - name: AWS_ACCESS_KEY_ID
#    valueFrom:
#      secretKeyRef:
#        name: aws-secret
#        key: access_key_id
#  - name: AWS_SECRET_ACCESS_KEY
#    valueFrom:
#      secretKeyRef:
#        name: aws-secret
#        key: secret_access_key

# -- Extra volumes to add to the polaris pod. See https://kubernetes.io/docs/concepts/storage/volumes/.
extraVolumes: []
  # - name: extra-volume
  #   emptyDir: {}

# -- Extra volume mounts to add to the polaris container. See https://kubernetes.io/docs/concepts/storage/volumes/.
extraVolumeMounts: []
  # - name: extra-volume
  #   mountPath: /usr/share/extra-volume

# -- Add additional init containers to the polaris pod(s) See https://kubernetes.io/docs/concepts/workloads/pods/init-containers/.
extraInitContainers: []
  # - name: your-image-name
  #   image: your-image
  #   imagePullPolicy: Always
  #   command: ['sh', '-c', 'echo "hello world"']

# -- Configures whether to enable the bootstrap metastore manager job
bootstrap:
  enabled: false
  # -- The names of the realms to bootstrap.
  realms: []
  # -- The credentials to create during the bootstrap. If you don't provide credentials for the
  # root principal of each realm to bootstrap, random credentials will be generated.
  # Each entry in the array must be of the form: realm,userName,clientId,clientSecret
  credentials: []
    # - realm1,root,root,s3cr3t
    # - realm2,root,root,s3cr3t
  # -- The image configuration for the bootstrap metastore manager job.
  image:
    # -- The image repository to pull from.
    repository: apache/polaris-admin-tool
    # -- The image pull policy.
    pullPolicy: IfNotPresent
    # -- The image tag.
    tag: "latest"
    # -- The path to the directory where the application.properties file, and other configuration
    # files, if any, should be mounted.
    configDir: /deployments/config
  # -- Extra environment variables to add to the bootstrap metastore manager job (see `extraEnv` for an example)
  extraEnv: []

tracing:
  # -- Specifies whether tracing for the polaris server should be enabled.
  enabled: false
  # -- The collector endpoint URL to connect to (required).
  # The endpoint URL must have either the http:// or the https:// scheme.
  # The collector must talk the OpenTelemetry protocol (OTLP) and the port must be its gRPC port (by default 4317).
  # See https://quarkus.io/guides/opentelemetry for more information.
  endpoint: "http://otlp-collector:4317"
  # -- Which requests should be sampled. Valid values are: "all", "none", or a ratio between 0.0 and
  # "1.0d" (inclusive). E.g. "0.5d" means that 50% of the requests will be sampled.
  sample: "1.0d"
  # -- Resource attributes to identify the polaris service among other tracing sources.
  # See https://opentelemetry.io/docs/reference/specification/resource/semantic_conventions/#service.
  # If left empty, traces will be attached to a service named "Polaris"; to change this, provide a service.name attribute here.
  attributes:
    {}
    # service.name: my-polaris

metrics:
  # -- Specifies whether metrics for the polaris server should be enabled.
  enabled: true
  # -- Additional tags (dimensional labels) to add to the metrics.
  tags:
    {}
    # service: polaris
    # environment: production

serviceMonitor:
  # -- Specifies whether a ServiceMonitor for Prometheus operator should be created.
  enabled: true
  # -- The scrape interval; leave empty to let Prometheus decide. Must be a valid duration, e.g. 1d, 1h30m, 5m, 10s.
  interval: ""
  # -- Labels for the created ServiceMonitor so that Prometheus operator can properly pick it up.
  labels:
    {}
  # release: prometheus
  # -- Relabeling rules to apply to metrics. Ref https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config.
  metricRelabelings: []
    # - source_labels: [ __meta_kubernetes_namespace ]
    #   separator: ;
    #   regex: (.*)
    #   target_label: namespace
    #   replacement: $1
    #   action: replace

# -- Logging configuration.
logging:
  # -- The log level of the root category, which is used as the default log level for all categories.
  level: INFO
  # -- The header name to use for the request ID.
  requestIdHeaderName: request_id
  # -- Configuration for the console appender.
  console:
    # -- Whether to enable the console appender.
    enabled: true
    # -- The log level of the console appender.
    threshold: ALL
    # -- Whether to log in JSON format.
    json: false
    # -- The log format to use. Ignored if JSON format is enabled. See
    # https://quarkus.io/guides/logging#logging-format for details.
    format: "%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c{3.}] [%X{requestId},%X{realmId}] [%X{traceId},%X{parentId},%X{spanId},%X{sampled}] (%t) %s%e%n"
  # -- Configuration for the file appender.
  file:
    # -- Whether to enable the file appender.
    enabled: false
    # -- The log level of the file appender.
    threshold: ALL
    # -- Whether to log in JSON format.
    json: false
    # -- The log format to use. Ignored if JSON format is enabled. See
    # https://quarkus.io/guides/logging#logging-format for details.
    format: "%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c{3.}] [%X{requestId},%X{realmId}] [%X{traceId},%X{parentId},%X{spanId},%X{sampled}] (%t) %s%e%n"
    # -- The local directory where log files are stored. The persistent volume claim will be mounted
    # here.
    logsDir: /deployments/logs
    # -- The log file name.
    fileName: polaris.log
    # -- Log rotation configuration.
    rotation:
      # -- The maximum size of the log file before it is rotated. Should be expressed as a Kubernetes quantity.
      maxFileSize: 100Mi
      # -- The maximum number of backup files to keep.
      maxBackupIndex: 5
      # -- An optional suffix to append to the rotated log files. If present, the rotated log files
      # will be grouped in time buckets, and each bucket will contain at most maxBackupIndex files.
      # The suffix must be in a date-time format that is understood by DateTimeFormatter. If the
      # suffix ends with .gz or .zip, the rotated files will also be compressed using the
      # corresponding algorithm.
      fileSuffix: ~  # .yyyy-MM-dd.gz
    # -- The log storage configuration. A persistent volume claim will be created using these
    # settings.
    storage:
      # -- The storage class name of the persistent volume claim to create.
      className: standard
      # -- The size of the persistent volume claim to create.
      size: 512Gi
      # -- Labels to add to the persistent volume claim spec selector; a persistent volume with
      # matching labels must exist. Leave empty if using dynamic provisioning.
      selectorLabels: {}
        # app.kubernetes.io/name: polaris
      # app.kubernetes.io/instance: RELEASE-NAME
  # -- Configuration for specific log categories.
  categories:
    org.apache.polaris: INFO
    org.apache.iceberg.rest: INFO
    # Useful to debug configuration issues:
    # io.smallrye.config: DEBUG
  # -- Configuration for MDC (Mapped Diagnostic Context). Values specified here will be added to the
  # log context of all incoming requests and can be used in log patterns.
  mdc:
    # aid=polaris
    # sid=polaris-service
    {}

realmContext:
  type: default
  realms:
    - default-realm

features:
  defaults:
    ENFORCE_PRINCIPAL_CREDENTIAL_ROTATION_REQUIRED_CHECKING: false
    SUPPORTED_CATALOG_STORAGE_TYPES:
      - S3
      - GCS
      - AZURE
      - FILE
  realmOverrides: {}
    # my-realm:
    #   ENFORCE_PRINCIPAL_CREDENTIAL_ROTATION_REQUIRED_CHECKING: true

persistence:
  type: eclipse-link  # in-memory
  eclipseLink:
    # -- The secret name to pull persistence.xml from.
    # If not provided, the default persistence.xml will be used.
    secret:
      name: ~
      key: persistence.xml
    # -- The persistence unit name to use. Only required if persistenceConfigSecret is set.
    persistenceUnit: polaris

fileIo:
  type: default

# -- Storage credentials for the server. If the following properties are unset, default credentials will be used.
storage:
  aws:
    accessKey: ~
    secretKey: ~
  gcp:
    token: ~
    lifespan: PT1H

authentication:
  authenticator:
    type: default
  tokenService:
    type: default
  tokenBroker:
    type: rsa-key-pair  # symmetric-key
    maxTokenGeneration: PT1H
    secret:
      name: ~
      publicKey: public.pem
      privateKey: private.pem
      secretKey: secret

cors:
  allowedOrigins:
    - http://localhost:8080
  allowedMethods:
    - PATCH
    - POST
    - DELETE
    - GET
    - PUT
  allowedHeaders:
    - "*"
  exposedHeaders:
    - "*"
  accessControlMaxAge: 600
  accessControlAllowCredentials: true

rateLimiter:
  type: no-op
  tokenBucket:
    type: default
    requestsPerSecond: 1000
    window: PT10S

tasks:
  maxConcurrentTasks: 100
  maxQueuedTasks: 1000
